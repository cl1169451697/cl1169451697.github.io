[{"title":"js高级总结","date":"2020-07-20T15:41:47.033Z","path":"2020/07/20/js高级总结/","text":"注意:*() :括号左边都是 函数; *. :点的左边是 对象; 1.在js调用函数时传递变量参数时, 是值传递还是引用传递理解1: 都是值(基本值/地址值)传递 理解2: 可能是值传递, 也可能是引用传递(地址值) 因为传递的都是值传递, 但是这个值是个—–&gt;地址值 2.js如何管理内存释放内存: 局部变量: 函数执行自动释放: 对象: 成为垃圾对象===&gt;垃圾回收器回收 3.什么是对象?多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中一个事物 3.1为什么使用对象?统一管理多个数据 3.2对象的组成?1.属性: 属性名(字符串)和 属性值(任意类型)组成===&gt;代表现实事物的状态数据 2.方法: 一种特别的属性(属性值是函数)====&gt;代表现实事物的行为数据 3.3如何访问对象内部数据?*.属性名 *[‘属性名’]==属性名包含特殊字符, 变量名不确定===&gt;使用 4.什么是函数? 函数声明，也叫具名函数*实现特定功能的多条语句的封装体 *只有函数是可以执行的, 其他类型的数据不能执行 *所有函数都是大写Function的实例(对象) 什么是命名函数?function fn() {} 也叫自定义函数,声明函数;有函数提升 什么是匿名函数?var fun = function() {} 也叫表达式函数,有变量提升 4.1为什么使用函数?*提高代码复用 *便于阅读交流 4.2如何创建函数?*函数声明 function fn(){} *表达式声明 var fn = function(){} *区别: *函数声明: 整体会被提升到当前作用域的顶部 函数表达式 也提升到顶部但是只有其*变量名**提升 如果有两个同名的函数;一个是表达式,一个是声明: 首先: 会把var提升到最上面,其次把声明函数提到上面,然后 4.3调用方式?*test(): 直接调用*obj.test(): 通过对象调用*new test(): new调用*test.call / apply(obj) ===&gt;改变this指向, 让一个函数成为指定任意对象的方法进行调用 4.4什么是回调函数?1).你定义的2).你没有调用3).但最终它执行了(在某个时刻,或者某个条件) 4.5常见的回调函数?*dom事件回调函数*定时器回调函数 ===&gt;用户交互*ajax回调函数 ===&gt;后台交互*生命周期回调函数 4.5匿名执行函数 ===立即执行函数====IIFE(function(){ console.log(‘立即执行我’) )() 4.6匿名函数: this指向windowreturn function(){ return this.name // 这里指向window } 4.7什么是高阶函数?对其他函数进行操作的函数,它接收函数作为参数或将函数作为返回值输出 作用:*隐藏实现 ===&gt;局部实现*不会污染外部(全局)空间*用它来编写js模块 5.this是什么?*任何函数本质上都是通过某个对象来调用的, 如果没有直接指定就是 window*所有函数内部都有一个变量this*它的值是调用函数的当前对象 5.1如何确定this的值?*test(): window*p.test(): p*new test(): 实例化的对象*p.call(obj): obj 5.2如何改变this指向?1.)函数.call 会调用函数, 可以改变this的指向(继承属性)2.).函数.apply 改变this指向和调动函数3.).bind 不会调用函数,可以改变this(返回一个新函数)***用的多,因为他不用绑定函数;(用于验证码点击禁用) 6.原型链:*所有函数.prototype对象 ===都是指着===&gt;Object.prototype; 但是Obeject函数除外 *所有函数._ proto _===都是指着===&gt;Funciton.prototype; *但是大写的Function函数: 的显示原型和隐式原型都指向 ===&gt;Function.prototype *Function的new是自生产的 *Function.prototype == ._ _proto _ _ ==&gt; Object.prototype == ._ _ proto _ _ =&gt; null *实例对象的隐式原型 === 构造函数的显示原型 12(Object.prototype &#x3D;&#x3D;&#x3D; Function.prototype.__proto__);&#x2F;&#x2F;true(Function.prototype &#x3D;&#x3D;&#x3D; Object.__proto__);&#x2F;&#x2F;true 7.执行上下文:1.全局上下文: 2.函数上下文 8.变量提升和函数提升变量先提升,然后函数提升, 变量提升的是var, 函数提升的整个函数体; 函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行 先看声明函数 ,再看 表达式函数,如果同名 ,表达式函数会把 声明函数覆盖!!! 在定义的函数名字和变量名相同的情况下，函数提升优先级高于变量的例子 8.1作用域和作用域链?作用域分为: 全局区域和函数区域; 作用: 隔离变量,可以在不同的作用域定义相同名称的变量不冲突; 作用域链:嵌套,可以用来查找变量,由内像外找,没找到就返回,找不到返回undefined 9.什么是闭包?说法1:) 内部函数引用了外部函数的变量时–就会产生闭包 说法2 :)包含被引用变量(函数)的对象; 被引用的那个变量的函数就是闭包函数 调试方法: 使用谷歌浏览器查看Scope **注意: 闭包存在于嵌套函数的内部数据中 9.产生闭包的条件?函数嵌套 内部函数引用了外部函数的数据(变量/ 函数) 9.1什么时候会产生闭包?执行函数定义就会产生闭包(不用调用内部函数), 函数定义是指: 执行了函数体但是没有 调用执行 9.1闭包的作用?1.) 使得函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)2.)让函数外部可以操作(读写)到函数内部的数据(变量 / 函数)3.)延伸了变量的作用范围 9.2.函数执行完后, 函数内部声明的局部变量是否还存在?一般是不存在的,因为函数已经结束了,存在闭包中的变量才可能存在; 9.3函数外部可以直接访问函数内部的局部变量吗?不能,但是可以通过闭包让外部操作操作它 9.4.闭包的缺点:函数执行后,函数内部的局部变量没有释放,占用内存时间会变长,容易造成内存泄露; 解决方法:及时释放: null 9.5闭包的生命周期:产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为了垃圾对象时 9.6闭包的引用:自定义js模块将所有的数据和功能封装在一个函数内部如果像外部暴露一个功能可以用方法, 暴露多个用对象包起来;模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能 10.内存溢出:程序运行的内存超过了剩余的内存空间,就会抛出内存溢出; 11.内存泄露占用的内存没有及时释放,积累多了就会导致内存溢出; 常见内存泄露:意外的全局变量没有及时清理的定时器或回调函数闭包 12.递归函数:函数内部自己调用自己, 这个函数就是递归函数;使用递归要加一个退出条件,不然容易出现栈溢出; 13工厂模式:通过工厂函数模式动态创建对象并返回使用场景: 需要创建多个对象;对象没有一个具体的类型,都是Object;返回一个对象的函数===&gt;工厂函数 14原型链继承:(得到方法) 重点是:1.)子类型的原型是父类型的一个实例对象; 子类型.prtotype = new 父类型() 2.)让子类型的原型的construtor重新指回子类型; 子类型.prototype.constructor = 子类型 15构造函数 (得到属性) + 原型(得到方法)— 继承最好的用法利用call()调用父级的方法 16.new一个对象背后做了些什么?*.创建了一个空对象 *给对象设置_ proto _,值为构造函数对象的prototype属性值 this._ proto _ = fn.prototype; *执行构造函数体(给对象添加属性 / 方法)","tags":[]},{"title":"mock","date":"2020-07-17T12:39:34.000Z","path":"2020/07/17/mock/","text":"先安装 mock.jsnpm install mockjs –save-dev 模拟数据接口在项目的src目录下创建一个mock目录，然后在里面新建一个index.js文件，作为mock的导出点，用于提供给src/main.js使用。在src/mock下新建modules目录，里面再新建各种xxx.js，用来模拟各个页面的数据。 src目录结构图: index.js代码: 12345678910111213141516// 引入mockjsimport Mock from 'mockjs'// 引入模板函数类import ratings from './modules/ratings'// Mock函数const &#123; mock &#125; = Mock// 设置延时Mock.setup(&#123; timeout: 400&#125;)// 使用拦截规则拦截命中的请求，mock(url, post/get, 返回的数据);mock(/\\/api\\/ratings\\/list/, 'post', ratings.list)// mock(/\\/api\\/ratings\\/list/, 'get', ratings.list) ratings.js代码:123456789101112131415161718192021222324// 引入随机函数import &#123; Random &#125; from 'mockjs'// 引入Mockconst Mock = require('mockjs')// 定义数据const listData = Mock.mock(&#123; 'data|20': [&#123; username: () =&gt; Random.cname(), time: () =&gt; Random.date('yyyy.M.d'), content: () =&gt; Random.csentence(5, 10) &#125;]&#125;)function list (res) &#123; // res是一个请求对象，包含: url, type, body return &#123; code: 200, data: listData.data, message: '请求成功' &#125;&#125;export default &#123; list &#125; mockjs使用Random方法生成随机数据的规则 官方文档 main.js中引入模拟数据接口:在 src/main.js 中需要加入以下代码 1import '@/mock' 安装axios npm install axios main.js中引入axios 123import axios from 'axios'// 配置axios 到原型中Vue.prototype.$axios = axios main.js完整代码: 12345678910111213141516import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'import axios from 'axios'import '@/mock'Vue.prototype.$axios = axiosVue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app') 页面使用: 打印数据:","tags":[{"name":"mock","slug":"mock","permalink":"https://github.com/cl1169451697/cl1169451697.github.io/tags/mock/"}]},{"title":"computed 和 watch","date":"2020-07-15T13:52:57.000Z","path":"2020/07/15/初次/","text":"computed:计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch:监听器:更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；","tags":[{"name":"computed | watch","slug":"computed-watch","permalink":"https://github.com/cl1169451697/cl1169451697.github.io/tags/computed-watch/"}]},{"title":"hexo基本配置","date":"2020-07-14T15:31:25.000Z","path":"2020/07/14/打开/","text":"hexo文档https://hexo.bootcss.com/docs/ 安装hexo:1npm install -g hexo-cli 初始化:1hexo init blog 启动:1hexo s 生成文件1hexo g 更新仓库1hexo d 清除缓存:1hexo clean 关联git:1cnpm install --save hexo-deployer-git 配置config文件:123type: gitrepo: https:&#x2F;&#x2F;gitee.com&#x2F;cl1169451697&#x2F;chenlong.gitbranch: master 配置_config文件12root: chenlong.giturl: https:&#x2F;&#x2F;gitee.com&#x2F;cl1169451697&#x2F;chenlong.git 常用博客样式:12https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yiliagit clone https:&#x2F;&#x2F;gitee.com&#x2F;cl1169451697&#x2F;hexo-theme-BlueLake.git themes&#x2F;yilia 修改_config.yml:themes: 设置为下载的主题名字 创建笔记1hexo new &quot;记录&quot; 参数1234title: BlueLake博客主题的详细配置tags: [hexo,BlueLake] &#x2F;&#x2F; 标签categories: Hexo博客折腾 &#x2F;&#x2F; 分类top: true &#x2F;&#x2F; 置顶","tags":[]},{"title":"Hello World","date":"2020-07-14T12:08:21.546Z","path":"2020/07/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]