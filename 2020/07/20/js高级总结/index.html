<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Pain is inevitable. Suffering is optional. 痛苦不可避免，但可以选择是否受苦。"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/cl1169451697.github.io/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/cl1169451697.github.io/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/cl1169451697.github.io/favicon.ico"><link rel="bookmark" href="/cl1169451697.github.io/favicon.ico"><link rel="apple-touch-icon" href="/cl1169451697.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/cl1169451697.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/cl1169451697.github.io/atom.xml"><title>js高级总结 | Chen的博客</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">js高级总结</h1><a id="logo" href="/cl1169451697.github.io/.">Chen的博客</a><p class="description">Pain is inevitable. Suffering is optional. 痛苦不可避免，但可以选择是否受苦。</p></div><div id="nav-menu"><a href="/cl1169451697.github.io/"><i class="fa fa-home"> 首页</i></a><a href="/cl1169451697.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/cl1169451697.github.io/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">js高级总结</h1><div class="post-meta"><a href="/cl1169451697.github.io/2020/07/20/js%E9%AB%98%E7%BA%A7%E6%80%BB%E7%BB%93/#comments" class="comment-count"></a><p><span class="date">Jul 20, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><p>*() :括号左边都是   函数;</p>
<p>*.  :点的左边是  对象;</p>
<h5 id="1-在js调用函数时传递变量参数时-是值传递还是引用传递"><a href="#1-在js调用函数时传递变量参数时-是值传递还是引用传递" class="headerlink" title="1.在js调用函数时传递变量参数时, 是值传递还是引用传递"></a>1.在js调用函数时传递变量参数时, 是值传递还是引用传递</h5><p>理解1: 都是值(基本值/地址值)传递</p>
<p>理解2: 可能是值传递, 也可能是引用传递(地址值)</p>
<p>因为传递的都是值传递,  但是这个值是个—–&gt;地址值</p>
<h5 id="2-js如何管理内存"><a href="#2-js如何管理内存" class="headerlink" title="2.js如何管理内存"></a>2.js如何管理内存</h5><p>释放内存:</p>
<p>局部变量:  函数执行自动释放:</p>
<p>对象:   成为垃圾对象===&gt;垃圾回收器回收</p>
<h5 id="3-什么是对象"><a href="#3-什么是对象" class="headerlink" title="3.什么是对象?"></a>3.什么是对象?</h5><p>多个数据的封装体</p>
<p>用来保存多个数据的容器</p>
<p>一个对象代表现实中一个事物</p>
<h5 id="3-1为什么使用对象"><a href="#3-1为什么使用对象" class="headerlink" title="3.1为什么使用对象?"></a>3.1为什么使用对象?</h5><p>统一管理多个数据</p>
<h5 id="3-2对象的组成"><a href="#3-2对象的组成" class="headerlink" title="3.2对象的组成?"></a>3.2对象的组成?</h5><p>1.属性:  属性名(字符串)和 属性值(任意类型)组成===&gt;代表现实事物的状态数据</p>
<p>2.方法:  一种特别的属性(属性值是函数)====&gt;代表现实事物的行为数据</p>
<h5 id="3-3如何访问对象内部数据"><a href="#3-3如何访问对象内部数据" class="headerlink" title="3.3如何访问对象内部数据?"></a>3.3如何访问对象内部数据?</h5><p>*.属性名</p>
<p>*[‘属性名’]==属性名包含特殊字符,  变量名不确定===&gt;使用</p>
<h5 id="4-什么是函数-函数声明，也叫具名函数"><a href="#4-什么是函数-函数声明，也叫具名函数" class="headerlink" title="4.什么是函数?  函数声明，也叫具名函数"></a>4.什么是函数?  函数声明，也叫具名函数</h5><p>*实现特定功能的多条语句的封装体</p>
<p>*只有函数是可以执行的, 其他类型的数据不能执行</p>
<p>*所有函数都是大写Function的实例(对象)</p>
<h5 id="什么是命名函数"><a href="#什么是命名函数" class="headerlink" title="什么是命名函数?"></a>什么是命名函数?</h5><p>function fn() {} 也叫自定义函数,声明函数;有函数提升</p>
<h5 id="什么是匿名函数"><a href="#什么是匿名函数" class="headerlink" title="什么是匿名函数?"></a>什么是匿名函数?</h5><p>var fun = function() {} 也叫表达式函数,有变量提升</p>
<h5 id="4-1为什么使用函数"><a href="#4-1为什么使用函数" class="headerlink" title="4.1为什么使用函数?"></a>4.1为什么使用函数?</h5><p>*提高代码复用</p>
<p>*便于阅读交流</p>
<h5 id="4-2如何创建函数"><a href="#4-2如何创建函数" class="headerlink" title="4.2如何创建函数?"></a>4.2如何创建函数?</h5><p>*函数声明 function fn(){}</p>
<p>*表达式声明 var fn = function(){}</p>
<p>*区别:</p>
<p>*函数声明:     整体会被提升到当前作用域的顶部</p>
<p><em>函数表达式   也提升到顶部但是只有其*</em>变量名**提升</p>
<p>如果有两个同名的函数;一个是表达式,一个是声明:</p>
<p>首先: 会把var提升到最上面,其次把声明函数提到上面,然后</p>
<h5 id="4-3调用方式"><a href="#4-3调用方式" class="headerlink" title="4.3调用方式?"></a>4.3调用方式?</h5><p>*test():  直接调用<br>*obj.test():  通过对象调用<br>*new test():  new调用<br>*test.call / apply(obj) ===&gt;改变this指向, 让一个函数成为指定任意对象的方法进行调用</p>
<h5 id="4-4什么是回调函数"><a href="#4-4什么是回调函数" class="headerlink" title="4.4什么是回调函数?"></a>4.4什么是回调函数?</h5><p>1).你定义的<br>2).你没有调用<br>3).但最终它执行了(在某个时刻,或者某个条件)</p>
<h5 id="4-5常见的回调函数"><a href="#4-5常见的回调函数" class="headerlink" title="4.5常见的回调函数?"></a>4.5常见的回调函数?</h5><p>*dom事件回调函数<br>*定时器回调函数    ===&gt;用户交互<br>*ajax回调函数    ===&gt;后台交互<br>*生命周期回调函数</p>
<h5 id="4-5匿名执行函数-立即执行函数-IIFE"><a href="#4-5匿名执行函数-立即执行函数-IIFE" class="headerlink" title="4.5匿名执行函数 ===立即执行函数====IIFE"></a>4.5匿名执行函数 ===立即执行函数====IIFE</h5><p>(function(){</p>
<p>console.log(‘立即执行我’)</p>
<p>)()</p>
<h5 id="4-6匿名函数-this指向window"><a href="#4-6匿名函数-this指向window" class="headerlink" title="4.6匿名函数:  this指向window"></a>4.6匿名函数:  this指向window</h5><p>return function(){</p>
<p>return this.name // 这里指向window</p>
<p>}</p>
<h5 id="4-7什么是高阶函数"><a href="#4-7什么是高阶函数" class="headerlink" title="4.7什么是高阶函数?"></a>4.7什么是高阶函数?</h5><p>对其他函数进行操作的函数,它接收函数作为参数或将函数作为返回值输出</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h5><p>*隐藏实现 ===&gt;局部实现<br>*不会污染外部(全局)空间<br>*用它来编写js模块</p>
<h5 id="5-this是什么"><a href="#5-this是什么" class="headerlink" title="5.this是什么?"></a>5.this是什么?</h5><p>*任何函数本质上都是通过某个对象来调用的, 如果没有直接指定就是 window<br>*所有函数内部都有一个变量this<br>*它的值是调用函数的当前对象 </p>
<h5 id="5-1如何确定this的值"><a href="#5-1如何确定this的值" class="headerlink" title="5.1如何确定this的值?"></a>5.1如何确定this的值?</h5><p>*test():      window<br>*p.test():     p<br>*new test():       实例化的对象<br>*p.call(obj):    obj</p>
<h5 id="5-2如何改变this指向"><a href="#5-2如何改变this指向" class="headerlink" title="5.2如何改变this指向?"></a>5.2如何改变this指向?</h5><p>1.)函数.call         会调用函数,  可以改变this的指向(继承属性)<br>2.).函数.apply    改变this指向和调动函数<br>3.).bind     不会调用函数,可以改变this(返回一个新函数)***用的多,因为他不用绑定函数;<br>(用于验证码点击禁用)</p>
<h5 id="6-原型链"><a href="#6-原型链" class="headerlink" title="6.原型链:"></a>6.原型链:</h5><p>*所有函数.prototype对象 ===都是指着===&gt;Object.prototype; 但是Obeject函数除外</p>
<p>*所有函数._ <em>proto</em> _===都是指着===&gt;Funciton.prototype;</p>
<p>*但是大写的Function函数:  的显示原型和隐式原型都指向 ===&gt;Function.prototype</p>
<p>*Function的new是自生产的</p>
<p>*Function.prototype     == ._ <em>_proto</em> _ _ <em>==&gt; Object.prototype ==</em>   ._ _ <em>proto</em> _ _ =&gt; null</p>
<p>*实例对象的隐式原型 === 构造函数的显示原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Object.prototype &#x3D;&#x3D;&#x3D; Function.prototype.__proto__);&#x2F;&#x2F;true</span><br><span class="line">(Function.prototype &#x3D;&#x3D;&#x3D; Object.__proto__);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h5 id="7-执行上下文"><a href="#7-执行上下文" class="headerlink" title="7.执行上下文:"></a>7.执行上下文:</h5><p>1.全局上下文:</p>
<p>2.函数上下文</p>
<h5 id="8-变量提升和函数提升"><a href="#8-变量提升和函数提升" class="headerlink" title="8.变量提升和函数提升"></a>8.变量提升和函数提升</h5><p>变量先提升,然后函数提升, 变量提升的是var, 函数提升的整个函数体;</p>
<p>函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行</p>
<p>先看声明函数 ,再看 表达式函数,如果同名 ,表达式函数会把 声明函数覆盖!!!</p>
<p>在定义的函数名字和变量名相同的情况下，函数提升优先级高于变量的例子</p>
<p><img src="E:%5C%E5%9F%B9%E8%AE%AD%5C%E9%BB%91%E9%A9%AC%5Cjs%E9%AB%98%E7%BA%A7%E5%A4%8D%E4%B9%A0%5C%E7%AC%94%E8%AE%B0%E5%9B%BE%5C6.%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.png" alt="6.变量提升"></p>
<h5 id="8-1作用域和作用域链"><a href="#8-1作用域和作用域链" class="headerlink" title="8.1作用域和作用域链?"></a>8.1作用域和作用域链?</h5><p>作用域分为: 全局区域和函数区域;</p>
<p>作用:  隔离变量,可以在不同的作用域定义相同名称的变量不冲突;</p>
<p>作用域链:嵌套,可以用来查找变量,由内像外找,没找到就返回,找不到返回undefined</p>
<h5 id="9-什么是闭包"><a href="#9-什么是闭包" class="headerlink" title="9.什么是闭包?"></a>9.什么是闭包?</h5><p>说法1:)  内部函数引用了外部函数的<strong>变量时</strong>–就会产生闭包</p>
<p>说法2 :)包含被引用变量(函数)的对象; 被引用的那个变量的函数就是闭包函数</p>
<p>调试方法:   使用谷歌浏览器查看Scope</p>
<p>**注意:  闭包存在于嵌套函数的内部数据中</p>
<h5 id="9-产生闭包的条件"><a href="#9-产生闭包的条件" class="headerlink" title="9.产生闭包的条件?"></a>9.产生闭包的条件?</h5><p>函数嵌套</p>
<p>内部函数引用了外部函数的数据(<strong>变量</strong>/ <strong>函数</strong>)</p>
<h5 id="9-1什么时候会产生闭包"><a href="#9-1什么时候会产生闭包" class="headerlink" title="9.1什么时候会产生闭包?"></a>9.1什么时候会产生闭包?</h5><p>执行函数定义就会产生闭包(不用调用内部函数),</p>
<p>函数定义是指: 执行了函数体但是没有  调用执行</p>
<h5 id="9-1闭包的作用"><a href="#9-1闭包的作用" class="headerlink" title="9.1闭包的作用?"></a>9.1闭包的作用?</h5><p>1.) 使得函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)<br>2.)让函数外部可以操作(读写)到函数内部的数据(变量 / 函数)<br>3.)延伸了变量的作用范围</p>
<h5 id="9-2-函数执行完后-函数内部声明的局部变量是否还存在"><a href="#9-2-函数执行完后-函数内部声明的局部变量是否还存在" class="headerlink" title="9.2.函数执行完后, 函数内部声明的局部变量是否还存在?"></a>9.2.函数执行完后, 函数内部声明的局部变量是否还存在?</h5><p>一般是不存在的,因为函数已经结束了,存在闭包中的变量才可能存在;</p>
<h5 id="9-3函数外部可以直接访问函数内部的局部变量吗"><a href="#9-3函数外部可以直接访问函数内部的局部变量吗" class="headerlink" title="9.3函数外部可以直接访问函数内部的局部变量吗?"></a>9.3函数外部可以直接访问函数内部的局部变量吗?</h5><p>不能,但是可以通过闭包让外部操作操作它</p>
<h5 id="9-4-闭包的缺点"><a href="#9-4-闭包的缺点" class="headerlink" title="9.4.闭包的缺点:"></a>9.4.闭包的缺点:</h5><p>函数执行后,函数内部的局部变量没有释放,占用内存时间会变长,容易造成内存泄露;</p>
<p>解决方法:<br>及时释放:  null</p>
<h5 id="9-5闭包的生命周期"><a href="#9-5闭包的生命周期" class="headerlink" title="9.5闭包的生命周期:"></a>9.5闭包的生命周期:</h5><p>产生:    在嵌套内部函数定义执行完时就产生了(不是在调用)</p>
<p>死亡:    在嵌套的内部函数成为了垃圾对象时</p>
<h5 id="9-6闭包的引用-自定义js模块"><a href="#9-6闭包的引用-自定义js模块" class="headerlink" title="9.6闭包的引用:自定义js模块"></a>9.6闭包的引用:自定义js模块</h5><p>将所有的数据和功能封装在一个函数内部<br>如果像外部暴露一个功能可以用方法, 暴露多个用对象包起来;<br>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</p>
<h5 id="10-内存溢出"><a href="#10-内存溢出" class="headerlink" title="10.内存溢出:"></a>10.内存溢出:</h5><p>程序运行的内存超过了剩余的内存空间,就会抛出内存溢出;</p>
<h5 id="11-内存泄露"><a href="#11-内存泄露" class="headerlink" title="11.内存泄露"></a>11.内存泄露</h5><p>占用的内存没有及时释放,积累多了就会导致内存溢出;</p>
<h6 id="常见内存泄露"><a href="#常见内存泄露" class="headerlink" title="常见内存泄露:"></a>常见内存泄露:</h6><p>意外的全局变量<br>没有及时清理的定时器或回调函数<br>闭包</p>
<h5 id="12-递归函数"><a href="#12-递归函数" class="headerlink" title="12.递归函数:"></a>12.递归函数:</h5><p>函数内部自己调用自己, 这个函数就是递归函数;<br>使用递归要加一个退出条件,不然容易出现栈溢出;</p>
<h5 id="13工厂模式"><a href="#13工厂模式" class="headerlink" title="13工厂模式:"></a>13工厂模式:</h5><p>通过工厂函数模式动态创建对象并返回<br>使用场景:  需要创建多个对象;<br>对象没有一个具体的类型,都是Object;<br>返回一个对象的函数===&gt;工厂函数</p>
<h5 id="14原型链继承-得到方法"><a href="#14原型链继承-得到方法" class="headerlink" title="14原型链继承:(得到方法)"></a>14原型链继承:(得到方法)</h5><p><img src="https://note.youdao.com/yws/public/resource/0e4f3105521054b2c8f4cd455c7439e1/xmlnote/WEBRESOURCE15dd791596f383f509c41ffd1dc8ceaf/3828" alt="image"></p>
<h5 id="重点是"><a href="#重点是" class="headerlink" title="重点是:"></a>重点是:</h5><p>1.)子类型的原型是父类型的一个实例对象;</p>
<p>子类型.prtotype = new 父类型()</p>
<p>2.)让子类型的原型的construtor重新指回子类型;</p>
<p>子类型.prototype.constructor = 子类型</p>
<h5 id="15构造函数-得到属性-原型-得到方法-—-继承最好的用法"><a href="#15构造函数-得到属性-原型-得到方法-—-继承最好的用法" class="headerlink" title="15构造函数 (得到属性) + 原型(得到方法)— 继承最好的用法"></a>15构造函数 (得到属性) + 原型(得到方法)— 继承最好的用法</h5><p>利用call()调用父级的方法</p>
<p><img src="https://note.youdao.com/yws/public/resource/0e4f3105521054b2c8f4cd455c7439e1/xmlnote/WEBRESOURCEe41047e191b82a9991225cc079e74123/3830" alt="image"></p>
<p><img src="https://note.youdao.com/yws/public/resource/0e4f3105521054b2c8f4cd455c7439e1/xmlnote/WEBRESOURCEab83be561c92bba8c353537e786e3ee9/3832" alt="image"></p>
<h5 id="16-new一个对象背后做了些什么"><a href="#16-new一个对象背后做了些什么" class="headerlink" title="16.new一个对象背后做了些什么?"></a>16.new一个对象背后做了些什么?</h5><p>*.创建了一个空对象</p>
<p>*给对象设置_ <em>proto</em> _,值为构造函数对象的prototype属性值</p>
<p>this._ <em>proto</em> _ = fn.prototype;</p>
<p>*执行构造函数体(给对象添加属性 / 方法)</p>
</div><div class="post-copyright"><blockquote><p>原文作者: CL</p><p>原文链接: <a href="https://github.com/cl1169451697/cl1169451697.github.io/2020/07/20/js高级总结/">https://github.com/cl1169451697/cl1169451697.github.io/2020/07/20/js高级总结/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/cl1169451697.github.io/2020/07/17/mock/" class="next">mock</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC81MTAzMS8yNzUxMw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#注意"><span class="toc-text">注意:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-在js调用函数时传递变量参数时-是值传递还是引用传递"><span class="toc-text">1.在js调用函数时传递变量参数时, 是值传递还是引用传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-js如何管理内存"><span class="toc-text">2.js如何管理内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-什么是对象"><span class="toc-text">3.什么是对象?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1为什么使用对象"><span class="toc-text">3.1为什么使用对象?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2对象的组成"><span class="toc-text">3.2对象的组成?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3如何访问对象内部数据"><span class="toc-text">3.3如何访问对象内部数据?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-什么是函数-函数声明，也叫具名函数"><span class="toc-text">4.什么是函数?  函数声明，也叫具名函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是命名函数"><span class="toc-text">什么是命名函数?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是匿名函数"><span class="toc-text">什么是匿名函数?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1为什么使用函数"><span class="toc-text">4.1为什么使用函数?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2如何创建函数"><span class="toc-text">4.2如何创建函数?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3调用方式"><span class="toc-text">4.3调用方式?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4什么是回调函数"><span class="toc-text">4.4什么是回调函数?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5常见的回调函数"><span class="toc-text">4.5常见的回调函数?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5匿名执行函数-立即执行函数-IIFE"><span class="toc-text">4.5匿名执行函数 &#x3D;&#x3D;&#x3D;立即执行函数&#x3D;&#x3D;&#x3D;&#x3D;IIFE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6匿名函数-this指向window"><span class="toc-text">4.6匿名函数:  this指向window</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7什么是高阶函数"><span class="toc-text">4.7什么是高阶函数?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#作用"><span class="toc-text">作用:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-this是什么"><span class="toc-text">5.this是什么?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1如何确定this的值"><span class="toc-text">5.1如何确定this的值?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2如何改变this指向"><span class="toc-text">5.2如何改变this指向?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-原型链"><span class="toc-text">6.原型链:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-执行上下文"><span class="toc-text">7.执行上下文:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-变量提升和函数提升"><span class="toc-text">8.变量提升和函数提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1作用域和作用域链"><span class="toc-text">8.1作用域和作用域链?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-什么是闭包"><span class="toc-text">9.什么是闭包?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-产生闭包的条件"><span class="toc-text">9.产生闭包的条件?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1什么时候会产生闭包"><span class="toc-text">9.1什么时候会产生闭包?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1闭包的作用"><span class="toc-text">9.1闭包的作用?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-函数执行完后-函数内部声明的局部变量是否还存在"><span class="toc-text">9.2.函数执行完后, 函数内部声明的局部变量是否还存在?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3函数外部可以直接访问函数内部的局部变量吗"><span class="toc-text">9.3函数外部可以直接访问函数内部的局部变量吗?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-4-闭包的缺点"><span class="toc-text">9.4.闭包的缺点:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5闭包的生命周期"><span class="toc-text">9.5闭包的生命周期:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-6闭包的引用-自定义js模块"><span class="toc-text">9.6闭包的引用:自定义js模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-内存溢出"><span class="toc-text">10.内存溢出:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-内存泄露"><span class="toc-text">11.内存泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#常见内存泄露"><span class="toc-text">常见内存泄露:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-递归函数"><span class="toc-text">12.递归函数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13工厂模式"><span class="toc-text">13工厂模式:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14原型链继承-得到方法"><span class="toc-text">14原型链继承:(得到方法)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重点是"><span class="toc-text">重点是:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15构造函数-得到属性-原型-得到方法-—-继承最好的用法"><span class="toc-text">15构造函数 (得到属性) + 原型(得到方法)— 继承最好的用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-new一个对象背后做了些什么"><span class="toc-text">16.new一个对象背后做了些什么?</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/cl1169451697.github.io/2020/07/20/js%E9%AB%98%E7%BA%A7%E6%80%BB%E7%BB%93/">js高级总结</a></li><li class="post-list-item"><a class="post-list-link" href="/cl1169451697.github.io/2020/07/17/mock/">mock</a></li><li class="post-list-item"><a class="post-list-link" href="/cl1169451697.github.io/2020/07/15/%E5%88%9D%E6%AC%A1/">computed 和 watch</a></li><li class="post-list-item"><a class="post-list-link" href="/cl1169451697.github.io/2020/07/14/%E6%89%93%E5%BC%80/">hexo基本配置</a></li><li class="post-list-item"><a class="post-list-link" href="/cl1169451697.github.io/2020/07/14/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/cl1169451697.github.io/categories/%E5%AD%A6%E4%B9%A0/">学习</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/cl1169451697.github.io/tags/computed-watch/" style="font-size: 15px;">computed | watch</a> <a href="/cl1169451697.github.io/tags/mock/" style="font-size: 15px;">mock</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/cl1169451697.github.io/archives/2020/">2020</a><span class="archive-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://chenlong.whqhart.top/#/" title="B站移动端" target="_blank">B站移动端</a><ul></ul><a href="https://cl1169451697.github.io/echarts.github.io/" title="ECharts可视化" target="_blank">ECharts可视化</a><ul></ul><a href="https://www.cnblogs.com/cl1998/" title="博客园" target="_blank">博客园</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/cl1169451697.github.io/baidusitemap.xml">网站地图</a> |  <a href="/cl1169451697.github.io/atom.xml">订阅本站</a> |  <a href="/cl1169451697.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/cl1169451697.github.io/." rel="nofollow">CL.</a></span><span> GitHub<a rel="nofollow" target="_blank" href="https://github.com/cl1169451697"> BlueLake.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?15af34e8f03131682093715f1d7ef015";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/cl1169451697.github.io/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/cl1169451697.github.io/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/cl1169451697.github.io/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/cl1169451697.github.io/share/css/share.css"><script type="text/javascript" src="/cl1169451697.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/cl1169451697.github.io/share/js/qrcode.js" charset="utf-8"></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>